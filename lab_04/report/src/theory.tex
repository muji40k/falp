\section*{Теоретические вопросы}
\addcontentsline{toc}{section}{Теоретические вопросы}

\subsection*{1. Синтаксическая форма и хранение программы в памяти}
В Lisp формы представления программы и обрабатываемых ею данных одинаковы
--- S-выражение. Программы могут обрабатывать и преобразовывать другие программы
или самих себя. В память программа представляется в виде списковых ячеек, так
как она состоит из S-выражений.

\subsection*{2. Трактовка элементов списка}
Если отсутствует блокировка вычислений, то первый элемент списка трактуется как
имя функции, а остальные элементы --- как аргументы функции.

\subsection*{3. Порядок реализации программы}
Программа выполняет следующий цикл операций:
\begin{enumerate}
    \item ожидание ввода S-выражения;
    \item обработка S-выражения интерпретатором --- функция \verb|eval|;
    \item вывод последнего результата на экран.
\end{enumerate}

\subsection*{4. Способы определения функции}
Функция может быть определена двумя способами. С помощью $\lambda$-выражения
\verb|(lambda (|$\lambda$\verb|-list) f)|, где $\lambda$-list --- список
формальных аргументов, а \verb|f| - тело функции, или макро-определения
\verb|(defun name |$\lambda$\verb|-выражение)|, где name --- имя определяемой
функции.

\subsection*{5. Работа со списками}
Функции, реализующие операции со списками, делятся на две группы.

\begin{itemize}
    \item Не разрушающие структуру функции; данные функции не меняют переданный
          им объект-аргумент, а создают копию, с которой в дальнейшем
          производят необходимые преобразования; к таким функциям
          относятся: \verb|append|, \verb|reverse|, \verb|last|,
          \verb|nth|, \verb|nthcdr|, \verb|length|, \verb|remove|,
          \verb|subst| и др.
    \item Структуроразрушающие функции; данные функции меняют сам
          объект-аргумент, из-за чего теряется возможность работать с исходным
          списком: чаще всего имя структуроразрушающих функций начинается
          с префикса \verb|-п|: \verb|nreverse|, \verb|nconc|, \verb|nsubst|
          и др.
\end{itemize}

Обычно в Lisp существуют функции-дубли, которые реализуют одно и то же
преобразование, но по разному (с сохранением структуры и без):
\verb|append/nconc|, \verb|reverse/nreverse| и т.д.

